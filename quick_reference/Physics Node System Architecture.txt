Physics Node System Architecture
Vision Summary
The goal is to create a flexible, bidirectional physics system where nodes act as "property clusters" that can be assigned to objects. These properties communicate with connected objects, enabling intuitive animation workflows without rigid patterns.
Proposed Node Architecture: 4 Core Physics Nodes
After analyzing common animation use cases and your design philosophy, I propose 4 physics nodes that balance power with simplicity:

1. BodyNode — "What this object IS physically"
The foundational physical identity of an object.

Property		|	Description
Type			|	Dynamic (moves) / Static (fixed) / Kinematic (animated)
Mass			|	Weight/heaviness (affects how forces move it)
Friction		|	Surface slipperiness (0 = ice, 1 = rubber)
Bounciness		|	Restitution (0 = stops dead, 1 = super bouncy)
Drag			|	Air resistance (slows movement over time)
Collision Shape		|	Box / Circle / Auto-hull from asset
Use cases: 		|	Ball physics, falling objects, slideable elements, any "physical object"

2. ForceFieldNode — "Gravity, Attraction & External Forces"
Creates fields that affect other objects, OR makes this object respond to fields.

Property		|	Description
Mode			|	Gravity / Attractor / Repulsor / Wind / Vortex
Direction		|	Emit FROM this object / Respond TO fields
Targets			|	Picker to select what's affected (or "affects me")
Strength		|	Force magnitude
Falloff			|	Linear / Quadratic / None (constant)
Radius			|	Area of effect


Bidirectional Example:

Particle Group gets ForceFieldNode → Mode: "Respond to Attractors" → will be pulled by any attractor
Object X gets ForceFieldNode → Mode: "Attractor" → Target Picker selects particle group
OR reverse: Particles → Mode: "Attracted to" → Picker selects Object X
Use cases: Magnetic particles, gravity wells, wind effects, vortexes, explosions

3. CollisionNode — "Collision & Surface Behaviors"
How this object interacts when touching others.

Property	Description
Surface Type	Solid / Trigger (detect only) / Platform (one-way)
Collision Group	Which group this belongs to
Collision Mask	Which groups it interacts with
Adhesion	Stickiness (0 = none, 1 = glue)
On Collision	Bounce / Stick / Stop / Trigger event
Use cases: Bouncing, platforms, sticky surfaces, collision detection for triggers

4. ConstraintNode — "Physical Connections Between Objects"
Links objects together with physical constraints.

Property	Description
Type	Spring / Rope / Weld / Hinge / Distance
Connected To	Picker to select linked object
Stiffness	How rigid (springs)
Damping	Oscillation reduction
Length	Rest distance (ropes)
Limits	Angle limits (hinges)
Use cases: Ragdolls, hanging signs, connected particles, chains, pendulums

Why This Grouping Works
Principle	How It's Satisfied
Property clusters	Each node groups related behaviors (not one per property)
Bidirectional	ForceFieldNode explicitly supports both directions via Picker
Intuitive	Names match what users think: "Body", "Force", "Collision", "Constraint"
Not overwhelming	Only 4 nodes cover all physics use cases
Flexible	Multiple ways to achieve same effect
Side panel config	Power is in configuration, not node explosion
Alternative Considerations
Should Gravity be separate from Attraction?
Argument for merging: They're both "forces that pull things" — gravity is just a constant-direction attractor.

Argument for splitting: Users think of "gravity" as fundamental and "magnetism" as special.

My recommendation: Keep merged in ForceFieldNode with Mode selector. Less nodes = less cognitive load.

Should there be a dedicated "Particle Physics" node?
Argument for: Particle systems often have unique needs (lifetime, spawn physics).

Argument against: Particles ARE just many BodyNodes with a ForceFieldNode responding to attractors.

My recommendation: No dedicated node. Particles get standard physics nodes. Their "particle-ness" is handled by the particle system itself, not by physics nodes.

Implementation Approach
Phase 1: Core Infrastructure
Create BodyNode with basic properties (mass, friction, bounce)
Implement physics engine bridge to publish position/velocity to aninodeStore
Add side panel controls
Phase 2: Forces
Create ForceFieldNode with gravity/attraction modes
Implement bidirectional Picker for target selection
Add field visualization (debug mode)
Phase 3: Collisions
Create CollisionNode with shape definitions
Implement collision detection and events
Add collision groups/masks
Phase 4: Constraints
Create ConstraintNode for linked physics
Implement spring, rope, weld types
Add visual constraint editor
Verification Plan
Manual Testing in NodeTester
Navigate to http://localhost:5173/tester
Add each physics node type
Verify side panel shows all configuration options
Test combinations of nodes on the preview object
Verify outputs (position, velocity) appear in the output panel
Integration Testing
Verify physics nodes publish to aninodeStore correctly
Test bidirectional Picker selection
Validate collision detection events

